# 八 排序

## 1 插入排序

就是相当于摸牌的过程，每次选好位置，移动后续元素，然后再插入元素。

复杂度是$O(n^2)$

### 1.1 折半插入排序

普通的版本，主要在于选位置时浪费太多时间。

如果我们用折半查找的方法，去寻找位置，就可以节省一点儿查找的时间。

复杂度$O(n^2)$

### 1.2 希尔排序

每次设置一个增量n，比如3,5等等。

然后每一轮比较时候，1和6比较，2和7比较，直到到达最后一个元素，交换这些元素的位置。

第二轮时候，1和4比较，2和5比较.....

通过这样几轮的运算，完成排序。

复杂度$O(n^2)$

## 2 交换排序

### 2.1 冒泡排序

每次选一个元素，与其他的元素逐个比较，大于（或小于）则交换，直到最后找到自己的位置。



## 3 选择排序

在整体中，每次挑出最小的一个元素，放到最前面，直到全部挑完。

### 3.1 简单选择排序

### 3.2 堆排序

就是大小根堆

题目中给出的是层序遍历的结果，展开写成二叉树。

开始的位置是$n/2下整$，我们设成m。为什么呢？因为二叉树中这个序号为根的子树，就是最后一个子树。

小根堆的调整是从的节点开始m，先调整好这个子树，根节点和左右孩子中最小的值交换（如果左右孩子相同，就选左边的那个）

接着看m-1序号为节点的子树，然后依次是m-2，m-3，直到全部调整完。

#### 性质

1. 建立堆的时间：O(n)
2. 插入/删除元素：O(logn)
3. 堆排序：O(nlogn)

## 4 归并排序

### 4.1 归并排序

复杂度Ologn

### 4.2 基数排序

就是按照每一位进行排序比大小。

其中利用到了一个链表。

1. 先按照个位进行排序，然后左到右，上至下进行排序

   ![image-20230809133803660](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230809133803660.png)

2. 接着是按照十位排序

   ![image-20230809133943421](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230809133943421.png)

最后排序完成

空间复杂度o（r）

时间复杂度O（n+r）n就是每一次分配n个元素的时间



## 5 外部排序

### 5.1 外部排序+多路归并败者树

归并排序解决的是，由于需要排序的文件太大，无法一次性读入内存排序，只能一部分接着一部分取出进行排序，然后再放回的操作。

二路归并：在内存中一次比较两路的数据，进行排序。

三路归并：在内存中一次比较三路的数据，排序后放入外存。

![image-20230809141930380](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230809141930380.png)

此时存在一个问题，当n路归并时，每一次选出一个元素，需要n-1次比较，很耗费时间，需要优化一下归并时比较的次数，就引入了**<u>*多路归并败者树*</u>**。

![image-20230809142147660](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230809142147660.png)

圆圈内写的是，比较后失败（不被选择元素的块号）

比如，选择最小的元素，6比12小，6被选中继续向上比较，写上了12号元素所在的4号块。

这样对于n路归并，从开始的n-1次比较，优化到了$logn$次。

### 5.2 置换选择排序和最佳归并树

反观上述的外部排序，虽然进行了优化，但是我们发现，导致性能低下的原因在于，**<u>*每个归并段的长度受到内存大小的限制，导致分成的段数太多。*</u>**

下面我们就要探索一个方法，尽量扩展归并段的长度！



这里左侧的黄框部分，就是待排文件，中间的框是代表内存工作区大小，这里为3，min关键字记录了每次比较完后，最小的元素值。

![image-20230809144337485](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230809144337485.png)

步骤：

1. 每次从需要排的元素中，取出元素放到内存工作区，选出一个最小的，放入归并段，然后补满工作区。
2. 直到工作区，选不出比min值更小的元素，这个归并段生成结束（比如22,6,45中没有比91更小的）
3. 得到的归并段，我们放到外存中，然后继续生成新的，我们会得到m个，长短不一的归并段

下面，我们将m个归并段进行合并！！

### 最佳归并树

就是以哈夫曼树的形式，去画一棵归并树。

这里为了满足分支是k段，需要补零分支，也就是虚段。

![image-20230809150728454](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230809150728454.png)

总得公式就是，度数=节点数-1

我们设置分支节点数为n

由于是5路归并，度数是5n

节点数的计算

1. 首先是n个分支节点
2. 接着是叶子节点，由于是18段，所以叶子节点为18
3. 然后就是补的虚段数，x
4. 最后减一就是度数

最后取整，反推出x的值。