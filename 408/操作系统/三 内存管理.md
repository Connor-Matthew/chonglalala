# 1三 内存

内存用来存放要用的数据，缓解外存和CPU之间的速度矛盾。

内存中每个存储单元，都会被编址，以供CPU方便进行查找！！



## 3.1 内存空间管理

### 覆盖技术

固定区：从始至终都要运行的程序段，一直放在内存中。

覆盖区：放置一些轮流使用的程序段，进行交换。 

![iShot_2023-08-20_15.59.03](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308201613806.png)

### 交换技术

 把某些进程暂时换出内存，把需要立刻运行的进程，换入内存！

## 3.2 分配方式

### 单一连续分配

内存分为两部分，低地址区域分配给系统进程，其他的区域是**用户区**

但是，用户空间内只可以存在一个**用户进程**，会产生很多内存碎片！！

> 内存碎片：内存中未被利用的已分配给用户进程的空间

### 固定分区分配

<img src="https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308201807739.png" alt="image-20230820180729719" style="zoom:33%;" />

 分配空间时，利用到了分区表。

每次有进程访问，就去搜索一个满足大小的，未分配分区。

**<u>*没有外部碎片，但是产生内部碎片*</u>**

> 外部碎片：内存中空闲空间太小，无法被充分利用
>
> 内部碎片：划分的区域内，没有被进程占满

### 动态分区分配

1. 分区表：依然是用分区表，记录分区号，起始地址，末尾地址，状态等。
2. 动态分区分配算法

##  3.3 动态分区算法

### 首次适应

 顺序的找，找到第一个满足的空闲分区，分配给进程。

### 最佳适应算法

找到最小的能满足当前进程的空闲分区。

此时的空闲分区表，会按空闲大小增大的趋势连接在一起。

### 最大适应算法

每次选最大的区域进行分配，为的是减小碎片的产生

### 邻近适应算法

![image-20230820212800525](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308202128727.png)

此处优化了每次都要从头查找的浪费时间问题。

于是乎，规定每次分配一个位置i后，下一次搜索位置从i+1处开始，当然，这时候就要用到循环链表了！

## 3.4 分页存储

 页面：

页面是按照逻辑地址划分的一个个小格子，用来描述进程所处的位置。

页框：

页框是按照物理地址设计的，用来描述内存的物理空间。

为了方便管理，进程的页面和内存的页框是一一对应的。

为了处理这样的对应关系，**<u>*诞生了页表！！*</u>**

![image-20230820215353746](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308202153769.png)

进程的每个页面，对应的放在了内存的某一个页框内。

#### 页号和页框号的存储

首先我们想这样一个问题，4GB的内存，每个页框号4kb，那么页框号的地址需要多少的空间呢？

> 4GB=2^32b  4kb = 2^12b 所以一共2^20次方个页框
>
> 为了存这些页框，需要20bit，由于每个字节8bit，一共需要3B（字节）的空间

至于页面号，由于是顺序存放，所以自然就有了顺序，我们不必单独存储。

在物理（页框）地址时，我们按照公式：
$$
物理地址=S+页面号*3 \\（S是起始地址）
$$

#### 逻辑地址逆推

已知逻辑地址S，则对应

1. 页号： S/页面大小
2. 页内偏移量：S%页面大小

由于二进制的特性，计算机可以很快的计算出上面两项

![image-20230820223226131](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308202232157.png)

这里我们可以观察到，如果每个页面是4KB，那么需要占用12位。

而第1页，是12位不变的基础上，增加一位表示1

第二页，则是增加两位10表示2，以此类推，第三页就是11+12位

因此我们的出结论：

1. 去掉页面大小之后的数字，代表页号
2. 而页面大小内的数字，则代表页内偏移量

#### 基本地址变换机构

用于实现**<u>*逻辑地址*</u>**到**<u>*物理地址*</u>**的转换

==页表寄存器PTR==

- 存储了**<u>*页表起始地址*</u>**还有**<u>*页表长度 M*</u>**

![image-20230823113504600](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308231135155.png)  

1. 首先划分出页号和页内偏移
2. 然后判断页号是否≤页表长度
3. 如果合法，就根据页号，直接从页表中找出**<u>*页框物理地址*</u>**
4. 再加上页内偏移量，就可以能找出内存单元了

⚠️注意：在计算页内偏移量时，页面大小是二进制的，比如 1k（2^10）=1024



#### 具有快表(TLB)的地址变换

快表是一种高速缓存，比内存速度快的多。

每次切换进程，快表的内容也会被清除！！

![image-20230823115129405](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308231151435.png)

首先去找快表，如果快表没有，再去看慢表。

每次查询完慢表后，就会复制一份到快表中！

#### 两级页表

![image-20230823120832499](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308231208539.png)

当页表项多起来之后，单个页表存太过冗长。

所以我们想着把页表项分部分，装进一个个内存块中。

比如 4kb 的内存块，可以存放 1024 个 4B 大小的页表项。

![image-20230823121242654](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308231212690.png)

#### 例题

![image-20230823121912127](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308231219157.png)

如图所示：

1. 前面10 位代表一级页号：从中可以找到存放页表项的内存块号
2. 中间 10 位代表二级页号：接着从 4 号页框中，找到 1 号的内存块号
3. 这个第二次访问的内存块号，就存放着数据，加上偏移量即可



## 3.5 基本分段存储管理



## 3.6 段页式管理方式



## 3.7 虚拟内存

1. 把最近常用到的数据，调入内存当中，局部性原理
2. 当空间不够时，进行空间的换进和换出工作

**<u>*这里要利用非连续分配技术*</u>**！！



### 请求分页管理方式

![image-20230824152334259](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308241523813.png)  

由于需要满足内存换出，还有内存调入的过程，此时需要增加一些字段进行记录。

#### 缺页中断

![image-20230824153657040](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308241536071.png)

### 页面置换算法

![image-20230824154007071](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308241540104.png)

### 1 OPT

 相当于开了天眼，选择出后续最长时间内不会出现的页面 ，换出内存。

### 2 FIFO

每次把最先进入的页面，置换出去

### 3 LRU

把最长时间未使用的页面换出

![image-20230824154939724](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308241549753.png)



当 3 号进入时，需要从 1，8，2，7 中找出一个进行置换。

我们逆向寻找发现，7 是最久未被使用的，于是把 7 置换出去。

### 4 时钟置换 

![image-20230824155347627](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308241553657.png)

基本思想就是，把分配过的内存连成一个循环队列，或者叫表盘，并且把访问位设置成 1。

当空间不够时，顺时针的扫描，找到 访问位为 0 的位置，进行置换！！

1. 如果全部都是 1，那么第一轮扫描失效，此时全部的访问位都变了 o
2. 第二轮扫描即可找到位置进行置换了 

### 4 改进型时钟算法

 ![image-20230824161218199](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308241612236.png)
