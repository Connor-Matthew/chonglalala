# 三 内存

内存用来存放要用的数据，缓解外存和CPU之间的速度矛盾。

内存中每个存储单元，都会被编址，以供CPU方便进行查找！！



## 3.1 内存空间管理

### 覆盖技术

固定区：从始至终都要运行的程序段，一直放在内存中。

覆盖区：放置一些轮流使用的程序段，进行交换。 

![iShot_2023-08-20_15.59.03](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308201613806.png)

### 交换技术

 把某些进程暂时换出内存，把需要立刻运行的进程，换入内存！

## 3.2 分配方式

### 单一连续分配

内存分为两部分，低地址区域分配给系统进程，其他的区域是**用户区**

但是，用户空间内只可以存在一个**用户进程**，会产生很多内存碎片！！

> 内存碎片：内存中未被利用的已分配给用户进程的空间

### 固定分区分配

<img src="https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308201807739.png" alt="image-20230820180729719" style="zoom:33%;" />

 分配空间时，利用到了分区表。

每次有进程访问，就去搜索一个满足大小的，未分配分区。

**<u>*没有外部碎片，但是产生内部碎片*</u>**

> 外部碎片：内存中空闲空间太小，无法被充分利用
>
> 内部碎片：划分的区域内，没有被进程占满

### 动态分区分配

1. 分区表：依然是用分区表，记录分区号，起始地址，末尾地址，状态等。
2. 动态分区分配算法

##  3.3 动态分区算法

### 首次适应

 顺序的找，找到第一个满足的空闲分区，分配给进程。

### 最佳适应算法

找到最小的能满足当前进程的空闲分区。

此时的空闲分区表，会按空闲大小增大的趋势连接在一起。

### 最大适应算法

每次选最大的区域进行分配，为的是减小碎片的产生

### 邻近适应算法

![image-20230820212800525](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308202128727.png)

此处优化了每次都要从头查找的浪费时间问题。

于是乎，规定每次分配一个位置i后，下一次搜索位置从i+1处开始，当然，这时候就要用到循环链表了！

## 3.4 分页存储

 页面：

页面是按照逻辑地址划分的一个个小格子，用来描述进程所处的位置。

页框：

页框是按照物理地址设计的，用来描述内存的物理空间。

为了方便管理，进程的页面和内存的页框是一一对应的。

为了处理这样的对应关系，**<u>*诞生了页表！！*</u>**

![image-20230820215353746](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308202153769.png)

进程的每个页面，对应的放在了内存的某一个页框内。

#### 页号和页框号的存储

首先我们想这样一个问题，4GB的内存，每个页框号4kb，那么页框号的地址需要多少的空间呢？

> 4GB=2^32b  4kb = 2^12b 所以一共2^20次方个页框
>
> 为了存这些页框，需要20bit，由于每个字节8bit，一共需要3B（字节）的空间

至于页面号，由于是顺序存放，所以自然就有了顺序，我们不必单独存储。

在物理（页框）地址时，我们按照公式：
$$
物理地址=S+页面号*3 \\（S是起始地址）
$$

#### 逻辑地址逆推

已知逻辑地址S，则对应

1. 页号： S/页面大小
2. 页内偏移量：S%页面大小

由于二进制的特性，计算机可以很快的计算出上面两项

![image-20230820223226131](https://picgo-sy.oss-cn-beijing.aliyuncs.com/img/202308202232157.png)

这里我们可以观察到，如果每个页面是4KB，那么需要占用12位。

而第1页，是12位不变的基础上，增加一位表示1

第二页，则是增加两位10表示2，以此类推，第三页就是11+12位

因此我们的出结论：

1. 去掉页面大小之后的数字，代表页号
2. 而页面大小内的数字，则代表页内偏移量
