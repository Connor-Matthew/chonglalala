# 四 指令系统

一条指令通常由两部分组成：

地址码和操作码

>我们可以这样理解，地址码给出数据的地址，操作码给出操作类型。

于是乎，我们就引出了一个问题，如何寻址，也就是如何根据地址码，获取到我们需要操作的数据！

## 寻址方式

有效寻址

1. 立即数寻址：指令中直接给出了操作数
2. 直接寻址：地址码给出的是直接的地址
3. 隐含寻址：

形式寻址

1. 间接寻址：给出的内存中，存放着有效地址

2. 寄存器寻址：给出了寄存器编号，寄存器中有操作书

3. 寄存器间接寻址：给出的寄存器中，存放着地址

4. 变址寻址：给出一个基地址（比如数组的起始地址）

5. 相对寻址：

6. 基址寻址：

   1. 带有基址寄存器：直接给出一个形式地址，加上基址地址即可

      ![image-20230626153133999](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230626153133999.png)

   2. 没有基址寄存器：给出一个寄存器作为基址，加上形式地址就是操作数所在地址

      ![image-20230626153147418](E:\chonglalala\408\计算机组成原理\image-20230626153147418.png)

      例题：

      ![image-20230626160323510](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230626160323510.png)

      由于是基址寻址，所以地址就是形式地址加寄存器内容：EFFF FF12H

      操作数呢，由于是字节编址，所以是12存在FF12H，34存在FF34H，00就存放在FF15H，由于最低位是00，所以选D

## 可变长操作码

这里就变得很有趣了，一开始我还被唬住了，发现其实并不难。

首先我们看图说话。

![image-20230627120542817](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230627120542817.png)

这里我们用4个字节去表示操作码，后边的12位表示三地址，那么最多可以表示16个三地址指令。

这里我们想要扩展地址怎么办呢？就用到了要介绍的，可变长操作码，具体如下：

将16位三地址码的最后一位改变，地址码从4位改为8位，并且前四位还是1111，如下图所示：

![image-20230627120317889](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230627120317889.png)

这时候，我们就有了15位三地址码，并且可以表示最多16种二地址码了。

同理，也可以把最后一位扩展成12位操作码，前8位是1，这样就有了1地址码。

甚至可以是16位全部作为操作码，前12位是1，就成了零地址码。

## 指令风格

### CISC风格

相对寻址时：pc+偏移量

### RISC风格

相对寻址时：pc+偏移量*指令的字节大小

简单来说，cisc是直接加字节数；而risc是加上指令数（比如一个指令占用两个字节）

## 标志位

这里其实比较简单！

我们要掌握四个标志位，这四个标志位是bool类型，只有0和1两种情况。

我们在做题时，只需要判断出它们的值，去选选项即可！

1. ZF零标志位：zf=1，代表等于0
2. CF进位借位：CF=1，有进位或者借位
3. OF溢出标志位：OF=1，表示有溢出
4. SF符号标志位：SF=1，表示负数

这里有个小结论：

>无符号数只看：CF和ZF
>
>有符号数只看：SF和OF

![image-20230627100801349](https://taufik.oss-cn-beijing.aliyuncs.com/img/image-20230627100801349.png)

选C

 
