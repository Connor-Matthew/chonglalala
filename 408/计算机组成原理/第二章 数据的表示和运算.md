# 第二章 数据的表示和运算

# 0前言

这一章算是比较难的部分，要理解数字如何在计算机中表示，存储的形式和运算。

好了，我们的旅程开始！！

# 1 数制与编码

计算机底层，是二进制的，由一个个**位（bit）**组成，而一个**字节（byte）**包含8个bit。

你可以把bit想象成一个个小格子，每个格子只能表示0或1。

![598A2396-EC5A-4557-A165-E2552BA01B36](https://picgo-sy.oss-cn-beijing.aliyuncs.com/test/598A2396-EC5A-4557-A165-E2552BA01B36.jpeg)

要表示3，就得进位，占用两个格子（位bit），写成11。

当然了，还引出了八进制和十六进制，而我们现实世界中，是十进制，所以就引出了相互转换的问题。

> 1. 二进制用B表示：1001B
> 2. 八进制用O：763B
> 3. 十六进制用H 或 0x：fabH or 0xfab



下面是举例的方法：

![WechatIMG4](https://picgo-sy.oss-cn-beijing.aliyuncs.com/test/WechatIMG4.jpeg)

### 十进制转任意进制

整数部分用短除，一直到商为0，余数从下到上，为最高位到最低位，倒着写。

至于小数部分，每次乘基数，然后取整，得到1.0000时结束，此时，余数部分顺着写，为最高位到最低位。

![WechatIMG5](https://picgo-sy.oss-cn-beijing.aliyuncs.com/test/WechatIMG5.jpeg)

### BCD码

二进制表示的十进制数



# 2 数据的排布和存储

上面我们介绍了基本的进制，计算机中是采用二进制表示数据的。

下面我们就要关心几个问题：

1. 这些二进制数据是如何放在或者叫 **排布** 到计算机的硬件中的呢？
2. 上一节讲到，cpu中的MDR根据“按地址存取”，访问数据，这个 **地址** 该如何设计呢？

##  2.1 地址

计算机把我们的主存，看作是**一个大的快递柜**，将其中的每一个小柜子都分配了一个编号，也叫地址。

这里称之为**虚拟地址**，因为是人为想出来方便我们使用的，并不是实际的物理地址。

在上面**1节编码**中，我们介绍了字节byte的概念，这里的一个字节，就是快递柜中的一个小柜子。



<u>***好了，现在有画面了，内存是一个大的快递柜，快递柜有很多小的柜子，而每个小柜子就是一个字节，一个字节又是8位。（1byte = 8bit）***</u>



我们在分配编号时，是按照小柜子分配的，所以说，**<u>*字节（小柜子）是计算机中最小的寻址单位*</u>**。

## 2.2 排布顺序

我们现在已经有了小柜子了！！就可以往里面填内容，去表示我们想要表达的数据啦！！

比如，我们有个数据比较大，一个柜子放不下，就需要多一些的柜子
$$
数据：01 23 45 67H
$$
我们来分析一下啊，首先是H结尾，也就代表十六进制！

而一个十六进制数，需要几位表示呢？4位！！1111刚好可以表示15，也就是十六进制最大的F！！

这时候，我们又知道，一个小柜子是一个字节，包含8位，所以，一个柜子里可以放两个十六进制数！

也就是如下这样的方式：
$$
01H\\ 23H\\ 45H\\ 67H
$$

### 大端法和小端法

我们把数据放到了多个柜子里，那么这些柜子如何排序呢？
$$
大端法(正常顺序): 01\ 23\ 45\ 67\\
小端法(倒序)\  :67\ 45\ 23\ 01
$$


## 2.3 数据对齐（待定）



# 3 数据的表示

这里有非常多的名词啊，定义啊，让人看的乱七八糟！

我很讨厌这些死板的名词，接下来就从最底层的原理开始讲起。

## 3.1 整数

### 无符号数

再次把字节的示意图搬过来：![E9FBE148-EE03-4E0C-B142-75D3D37656AF](https://picgo-sy.oss-cn-beijing.aliyuncs.com/test/E9FBE148-EE03-4E0C-B142-75D3D37656AF.jpeg)

我们就用瞪眼法，仔细的审视一下这个字节，就是这么8个位，可以放的数字，无非是0和1。

全是1 ：256 -1 = 255；全是0：0

**<u>*就是这么简单，可以表示 0 ～ 255，这个范围里的整数。*</u>**
$$
[0101] = 0*2^3 + 1*2^2 + 0 *2^1 + 1 *2^0 = 5
$$
这就是无符号数！！但这就存在一个问题，上述的方法没有负数，于是我们就得想个办法，表示负数！

很自然的，我们就想着，增加一个标志，或者叫符号，去区分正和负！

### 有符号数

有符号数涉及到了减法运算，实现起来很复杂。

所以计算机中用**<u>*补码表示有符号数*</u>**，因为补码的减法可以用加法去代替！！！

> 补码：正数的补码就是原码，而负数的补码是除了符号位之外，全部取反，然后+1                



图中展示的红色部分，就是符号位，或者**<u>*叫负权重位*</u>**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

![A1A4F2F7-2A73-41DF-935E-D1699D9DB0F7](https://picgo-sy.oss-cn-beijing.aliyuncs.com/test/A1A4F2F7-2A73-41DF-935E-D1699D9DB0F7.jpeg)

这个位置有着极大的负权重
$$
X^{w-1}*(-2^{w-1})
$$
当X为0时，负权重消失，就是正数，也就是源码本身，比如
$$
[0101] = 0 *-2^3 + 1*2^2+0*2^1+1*2^0 = 5
$$
当X为1时，引入负权重，比如
$$
[1011] = 1 *-2^3 + 0*2^2+1*2^1+1*2^0 = -5
$$

### 练习

1. 求-5的补码表示

   负的五= 1+0101 = 1101；然后取反 1010 ； +1 = 1011

2. 已知补码是1011，求源码？

   先减1:1010 ； 然后取反：1101 ； 拆成1 + 0101 也就是-5

### 有符号数的范围

$$
-2^{w}\ to\ 2^{w-1} -1 \\
零：0000000
$$



 

## 3.2 整数的运算

## 无符号数的加法

$$
\begin{equation}
x+y=
\begin{cases}
x+y& \text{ $ x + y <2^w $ } \\
x+y-2^w& \text{ $ x + y >=2^w $ }
\end{cases}
\end{equation}
$$

这里比较好理解，当x+y在安全范围内，得到的结果就是相加的和；但是当结果过大，产生了溢出，其结果就是真实值减去w位所能表示的最大数值。

比如最大范围是8时，255 + 1 = 256 = 1 + 8个0 （一共9位），超出了8位的空间，所以表示的值是0。

那么在计算中，我们该如何判断是否溢出呢？其实很简单，如果sum>=x(或者y)，就说明没有溢出，反之溢出





## 有符号数运算

有符号数要更加复杂一点儿，因为涉及到了负数部分。

我们把x+y的结果，计作sum。

正常情况下,如果sum在范围内，表达的值就是sum。
$$
-2^{w-1}<= sum <= 2^{w-1}-1
$$
如果发生了溢出，比如，超过了上限，sum会变成什么呢
$$
sum = sum - 2^{w}
$$
因为此时进位的1，会把符号位改变，也就是增加了一个负权重，1+127 = 1+127-256 = -128

此时，如果超越了下界，又会变成怎么样呢？
$$
-128 = 10000000 \\
-1 = 11111111 \\
二者相加：（1）01111111 = 127
$$
此时我们可以看到，由于1+1 是10，失去了负权重，所以加上256

对于没有下溢出的情况：
$$
-127 = 10000001 \\
-1 = 11111111 \\
二者相加：（1）10000000 = -128\\
$$
由于后面的进位，1+1+1 = 11，使得负权重位的1保留，所以没有影响



## 逆元

简单来说，x + x‘ = 0，x’就是x的逆元。

对于无符号数，我们用溢出的方式求得
$$
x=0:x'=0\\
x!=0:x'=2^w -1
$$
对于有符号数，稍微变化一些，当x不是负的最小值时，x‘是-x

如果x是最小值，那么此时x’就是x本身，因为只有x本身相加，才能制造出负溢出。





## 乘法和除法
